% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/import.r, R/import_package.r
\name{import_}
\alias{import_}
\alias{import}
\alias{import_package_}
\alias{import_package}
\title{Import a module into the current scope}
\usage{
import_(module, attach, attach_operators = TRUE, doc)

import(module, attach, attach_operators = TRUE, doc)

import_package_(package, attach, attach_operators = TRUE)

import_package(package, attach, attach_operators = TRUE)
}
\arguments{
\item{module}{a character string specifying the full module path}

\item{attach}{either a boolean or a  character vector. If \code{TRUE}, attach
the newly loaded module to the object search path (see \code{Details}).
Alternatively, if a character vector is given, attach only the listed names.}

\item{attach_operators}{if \code{TRUE}, attach operators of module to the
object search path, even if \code{attach} is \code{FALSE}}

\item{doc}{boolean specifying whether to load the module’s documentation (see
\code{Details})}

\item{package}{a character string specifying the package name}
}
\value{
the loaded module environment (invisible)
}
\description{
\code{module = import('module')} imports a specified module and makes its
code available via the environment-like object it returns.
}
\details{
Modules are loaded in an isolated environment which is returned, and
optionally attached to the object search path of the current scope (if
argument \code{attach} is \code{TRUE}).
\code{attach} defaults to \code{FALSE}. However, in interactive code it is
often helpful to attach packages by default. Therefore, in interactive code
invoked directly from the terminal only (i.e. not within modules),
\code{attach} defaults to the value of \code{options('import.attach')}, which
can be set to \code{TRUE} or \code{FALSE} depending on the user’s preference.

\code{attach_operators} causes \emph{operators} to be attached by default,
because operators can only be invoked in R if they re found in the search
path. Not attaching them therefore drastically limits a module’s usefulness.

\code{doc} loads the module’s documentation, specified as roxygen comments.
It defaults to \code{TRUE} in interactive mode and to \code{FALSE} otherwise.

Modules are searched in the module search path \code{options('import.path')}.
This is a vector of paths to consider, from the highest to the lowest
priority. The current directory is \emph{always} considered last. That is,
if a file \code{a.r} exists both in the current directory and in a module
search path, the local file \code{./a.r} will not be loaded, unless the
import is explicitly specified as \code{import('./a')}.

Module names can be fully qualified to refer to nested paths. See
\code{Examples}.

Module source code files are assumed to be encoded in UTF-8 without BOM.
Ensure that this is the case when using an extended character set.

\code{pkg = import_package('pkg')} imports a package and treats it much as if
it were a module, making package contents available in the \code{pkg}
variable.
}
\note{
Unlike for \code{\link{library}}, attaching happens \emph{locally}: if
\code{import} is executed in the global environment, the effect is the same.
Otherwise, the imported module is inserted as the parent of the current
\code{environment()}. When used (globally) \emph{inside} a module, the newly
imported module is only available inside the module’s search path, not
outside it (nor in other modules which might be loaded).
}
\examples{
\dontrun{
# `a.r` is a file in the local directory containing a function `f`.
a = import('a')
a$f()

# b/c.r is a file in path `b`, containing functions `f` and `g`.
import('b/c', attach = 'f')
# No module name qualification necessary
f()
g() # Error: could not find function "g"

import('b/c', attach = TRUE)
f()
g()
}
\dontrun{
dplyr = import_package('dplyr')
# Not attached, so we cannot do:
#cars = tbl_df(cars)
# Instead, this works:
cars = dplyr$tbl_df(cars)
# But this invokes the correct `print` method for class `tbl_df`:
print(cars)
}
}
\seealso{
\code{\link{unload}}

\code{\link{reload}}

\code{\link{module_name}}

\code{\link{module_help}}
}
